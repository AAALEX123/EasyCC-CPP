#include <easycc/tools/ConvertFF.h>
#include <easycc/Grammar.h>
#include <iostream>
#include <getopt.h>
#include <fstream>

#include <boost/log/sources/logger.hpp>
#include <boost/log/sources/record_ostream.hpp>
#include <boost/log/sources/global_logger_storage.hpp>
#include <boost/log/utility/setup/file.hpp>
#include <boost/log/utility/setup/common_attributes.hpp>
#include <boost/log/utility/setup/console.hpp>
#include <easycc/EasyCC.h>

namespace logging = boost::log;
namespace src = boost::log::sources;
namespace keywords = boost::log::keywords;
namespace sinks = boost::log::sinks;

BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT(ecc_logger, src::logger_mt)

namespace ecc{

    void ConvertFF::init(int argc, char*argv[]) {

        // Init logs
        logging::add_common_attributes();
        logging::core::get()->set_logging_enabled(false);

        // Initialize parameters
        initParams(argc, argv);
    }

    void ConvertFF::convert(std::string fileName) {

        // Process the grammar file
        Grammar grammar(fileName);

        // Prepare output file
        std::ofstream file(m_outputFile);

        std::map<std::string, std::shared_ptr<std::set<std::string>>> m_firstSet;
        std::map<std::string, std::shared_ptr<std::set<std::string>>> m_followSet;
        std::map<std::string, std::shared_ptr<std::map<std::string,
                std::shared_ptr<std::vector<std::string>>>>> m_parseTableMap;

        // Check if can open file
        if(!file.is_open()) {
            std::cerr << "Cannot open file: " << m_outputFile << std::endl;
        } else {

            // Write header comments
            file    << "/**" << std::endl
                    << " * THIS FILE IS AUTO GENERATED BY ConvertFF" << std::endl
                    << " * DO NO MAKE ANY CHANGES" << std::endl
                    << " **/" << std::endl;

            // Write the includes
            file    << "#include <string>" << std::endl
                    << "#include <map>" << std::endl
                    << "#include <memory>" << std::endl
                    << "#include <set>" << std::endl;

            // Write the grammar data
            file    << "std::string start = \"" << grammar.m_start << "\";" << std::endl;
            file    << "std::map<std::string, std::shared_ptr<std::set<std::string>>> firstSet;" << std::endl;
            file    << "std::map<std::string, std::shared_ptr<std::set<std::string>>> followSet;" << std::endl;
            file    << "std::map<std::string, std::shared_ptr<std::map<std::string," << std::endl
                    << "            std::shared_ptr<std::vector<std::string>>>>> parseTableMap;" << std::endl;
        }

        file.close();
    }

    void ConvertFF::printUsage() {
        std::cout
        << "First Follow - Convert syntax grammar into a C++ header file" << std::endl
        << "Usage: firstfollow [OPTION]... FILE" << std::endl
        << "\t-o, --output\t\t\tOutput file" << std::endl
        << "\t-v, --verbose\t\t\tVerbose mode" << std::endl
        << "\t-h, --help\t\t\tDisplay this help message" << std::endl;
    }

    void ConvertFF::initParams(int argc, char *argv[]) {

        struct option longOptions[] = {
                {"verbose", no_argument, 0, 'v'},
                {"output", required_argument, 0, 'o'},
                {"help", no_argument, 0, 'h'},
                {0, 0, 0, 0}
        };

        int optionIndex = 0;
        int c;
        while ((c = getopt_long(argc, argv, "hvo:", longOptions, &optionIndex)) != -1) {
            switch (c) {
                case 'v':
                    logging::add_console_log(
                            std::cout,
                            boost::log::keywords::format = "[%TimeStamp%]: %Message%"
                    );
                    logging::core::get()->set_logging_enabled(true);
                    break;
                case 'o':
                    m_outputFile = optarg;
                    break;
                case 'h':
                default:
                    // Print by default
                    break;
            }
        }
    }
}

int main(int argc, char *argv[]) {
    ecc::ConvertFF convertFF;
    convertFF.init(argc, argv);

    // If no file was specified, print usage
    int fileIndex = optind;
    if(fileIndex >= argc || convertFF.getOutputFile().empty()) {
        convertFF.printUsage();
        return 1;
    }

    // Convert file
    convertFF.convert(argv[fileIndex]);

    return 0;
}