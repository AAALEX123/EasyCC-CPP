# Syntax analysis

## Description
Syntax analysis is the second phase in compiler design where the lexical tokens generated by the lexical 
analyzer are validated against a grammar defining the language syntax. 

## I - Grammar
A language syntax is determined by a set of productions forming a grammar. Constructed grammars must 
satisfy the LL(1) (left to right, leftmost derivation, 1 lookahead) conditions.

### LL(1) Conditions
#### A - No left recursion

Example of a left recursion
```java
A -> A a | b
```
Solution for a left recursion
```java
A -> b B
B -> a B | ε
```

#### B - Intersection of First sets in same production must be empty
Example of a non-empty intersection of First sets in a same production
```java
A -> B C | D E
B -> F G
D -> F H
```
In the above grammar, First(F) ∈ First(B) and First(F) ∈ First(D), therefore First(B) ∩ First(D) ≠ {}

One solution for this problem
```java
A -> F I
I -> G C | H E
```

#### C - Intersection of First and Follow sets of a non-terminal must be empty
Example of a non-empty intersection of First and Follow sets of a non-terminal

```java
A -> B a
B -> a | ε
```
In the above grammar, First(B) ∩ Follow(B) = {a}

One solution for this problem
```java
A -> a C
C -> a | ε
```

### JSON structure
<b>Terminals and Non-terminals</b>

* Non-terminals must be composed of upper case letters and underscore only. (Cannot be part of
<a href="#reserved-syntax-keyword">Reserved syntax keywords</a>)
* Terminals must begin and end with a single quote. The text in between the single quotes defines the
lexical token name (case sensitive) and should not contain spaces. (Cannot be part of
<a href="#reserved-syntax-keyword">Reserved syntax keywords</a>)
* `EPSILON` represents an epsilon production.
* Whitespaces between tokens are delimiters.

<b>Global keys table</b>
<table>
    <tr>
        <th>Key</th>
        <th>Key description</th>
        <th>Value</th>
    </tr>
    <tr>
        <td rowspan="4">non-terminal (e.g. <code>T_IF</code>)</td>
        <td rowspan="4">The non-terminal that can be replaced by its value.</td>
        <td>Array of non-terminals string (e.g. <code>["NT_A NT_B NT_C"]</code>)</td>
    </tr>
    <tr>
        <td>Array of a terminal string (e.g. <code>["'if'"]</code>)</td>
    </tr>
    <tr>
        <td>Array of an epsilon string (e.g. <code>["EPSILON"]</code>)</td>
    </tr>
    <tr>
        <td>Array of a mix strings (e.g. <code>["NT_A NT_B NT_C", "'if'", "EPSILON"]</code>)</td>
    </tr>
    <tr>
        <td colspan="4"><i>Note: The above row can be applied several times in this object</i></td>
    </tr>
</table>

<b id="reserved-syntax-keyword">Reserved syntax keyword table</b>
<table>
    <tr>
        <th>Lexical Keyword</th>
    </tr>
    <tr>
        <td><code>:any</code></td>
    </tr>
    <tr>
        <td><code>$</code></td>
    </tr>
</table>


## II - Syntax error messages
When the user input does not align with the language grammar, the syntax analyzer will try to recover
from the panic mode and will report customized error messages describing each situation.

### JSON structure
<b>Global keys table</b>
<table>
    <tr>
        <th>Key</th>
        <th>Description</th>
        <th>Value</th>
        <th>Value description</th>
        <th>Required</th>
    </tr>
    <tr>
        <td>default_message</td>
        <td>A default message, used if no specific message is defined for a particular situation.</td>
        <td>string</td>
        <td>General error message. The string can contain <a href="#optional-placeholders">optional placeholders</a>.</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>error_messages</td>
        <td>Specific message for a particular situation.</td>
        <td>Array of <a href="#error-message-object">error message objects</a></td>
        <td>Check table</td>
        <td>Yes</td>
    </tr>
</table>

<b id="error-message-object">Error message object table</b>
<table>
    <tr>
        <th>Key</th>
        <th>Key description</th>
        <th>Value</th>
        <th>Value description</th>
    </tr>
    <tr>
        <td rowspan="3">non_terminal</td>
        <td rowspan="3">Non-terminal expected by the syntax analyzer at a specific location in the input</td>
        <td>string</td>
        <td>Non-terminal (e.g. <code>T_VAR_NAME</code>)</td>
    </tr>
    <tr>
        <td><code>:any</code></td>
        <td>Any non-terminal</td>
    </tr>
    <tr>
        <td><code>$</code></td>
        <td>End of grammar</td>
    </tr>
    <tr>
        <td rowspan="3">terminal</td>
        <td rowspan="3">Actual terminal read by the syntax analyzer</td>
        <td>string</td>
        <td>Terminal (e.g. <code>'equal_sign'</code>)</td>
    </tr>
    <tr>
        <td><code>:any</code></td>
        <td>Any terminal</td>
    </tr>
    <tr>
        <td><code>$</code></td>
        <td>End of file</td>
    </tr>
    <tr>
        <td>message</td>
        <td>Error message</td>
        <td>string</td>
        <td>Meaningful message on what was added or unexpected.<br/>(e.g. 'Missing variable name before the 
        assignment operator at line ${lexical.line}').<br/>The string can contain 
        <a href="#optional-placeholders">optional placeholders</a>.</td>
    </tr>
</table>


<b id="optional-placeholders">Placeholders table</b>
<table>
    <tr>
        <th>Placeholder</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><code>${lexical[.next|.previous]\*.value}</code></td>
        <td>Display the value of the token object</td>
    </tr>
    <tr>
        <td><code>${lexical[.next|.previous]\*.column}</code></td>
        <td>Display the column number in the line starting from 1</td>
    </tr>
    <tr>
        <td><code>${lexical[.next|.previous]\*.line}</code></td>
        <td>Display the line number in the text starting from 1</td>
    </tr>
    <tr>
        <td><code>${filename}</code></td>
        <td>Input file name.</td>
    </tr>
</table>
