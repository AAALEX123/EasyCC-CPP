EasyCC C++ [![Build Status](https://travis-ci.org/amirbawab/EasyCC-CPP.svg?branch=master)](https://travis-ci.org/amirbawab/EasyCC-CPP)
============

EasyCC C++ (Easy Compiler Compiler) is a library allowing users to easily develop their own programming language. The project does not require wrting any line of code for the lexical and syntax analysis phases. The configurations of the latters are provided as JSON files to the library. Adding the logic for a programming language is done by simply registering semantic action handlers in order to gradually build the structure of the input and eventually generating output code.

To learn more about how it works, read the documentation and/or check the step by step tutorial below.

### Difference between EasyCCDev and EasyCCPro
Both libraries use the same Lexical and Syntax algorithms, and switching from one library to another requires minor changes. 
* EasyCCDev (EasyCC development mode) takes the JSON files as arguments in the final executable. This is useful during the development phase because the program does not need to be recompiled to apply changes in the JSON files.
* EasyCCPro (EasyCC production mode) takes the JSON files as arguments to the CMake. The compile process for your program will be composed of two steps. First is embedding the JSON files into the executable. Second is compiling your program with the generated files.

### Links
* Project UML: <a href="https://drive.google.com/file/d/0B8fWEFscW3Z4SzlpMnpETkdPOGs/view">UML Draw.io</a>
* Lexical Analysis: <a href="src/lexical">Documentation</a>
* Syntax Analysis: <a href="src/syntax">Documentation</a>

### Learn by examples
#### Calculator programming language
This example is a step by step tutorial on how to use EasyCC-C++ to build a very simple programming language. The program will read an input file and produce an output file. The input file is composed of integer numbers (operands) and arithmetic symbols (operatos). The output produced is the mathematical result of the calculation written in the input file.

#### Step 1: Create a "lexical_state_machine.json" file
Lexical state machine converts a sequence of characters into lexical tokens. For instance, one can define a sequence of consecutive positive number as an `integer` token. Following this rule, the lexical analyzers will replace positive numbers in the input file, such as `1`, `123`, etc..., by the lexical token `integer`, then move to the next sequence of characters and apply the corresponding rule. Lexical tokens generated by the lexical analyzer are stored in a list, required later by the syntax analyzer.  

A lexical state machine can easily grow, even for a simple programming language like the one covered in this tutorial. Therefore, a graphical tool has been developed in order to facilitate this task. The web based tool uses forms and a JavaScript based graph to populate the state machine. Once the state machine is complete, the data can be exported in JSON format and served as a first configuration input to the EasyCC C++ library. 

In the calculator programming language, the lexical state machine defines three main categories of tokens. The first category is the integer lexical tokens. As described previously, an integer is composed of sequece of positive numbers or zero. To keep this tutorial simple, negative values are not allowed. The second category represents the arithmetic operators, composed of symbols like plus, minus, divide, multiply. The third category is allowing comments. Even if they are not very necessary for that language, comments are a good example of how to mark an end of line/file case as the end of the lexical token. Finally, a single state is added to the state machine to signal an invalid character. Characters that land on this state are considered error tokens, and later used to display error messages on the console. Having this configuration file only is not enough to tell the library that this token is not part of the input and should trigger error messages. The next step shows how to configure the library to interpret the generated lexical tokens.  

Web tool: <a href="tools/gui">State machine</a> (Language: TypeScript. Compile `.ts` files in `ts/` directory. E.g.`tsc @compile`)  
Lexical state machine: <a href="resources/src/calculator/lexical_state_machine.json">lexical_state_machine.json</a>  
JSON description: <a href="src/lexical#state-machine">Doc</a>

#### Step 2: Create a "lexical_config.json" file
After passing the input through the state machine and generating the lexical tokens, the library needs to know which of the lexical tokens are not part of the language, and which ones should be ignored. The information provided in this configuration file is sufficient for the library to classify lexical tokens into three primary boxes. 

The first box contains lexical tokens which can safely be ignored because they do not contribute to the structure of the code. A common case here are comments. Usually, comments are not needed for the next phase of the compiler since they are used for the developer to keep their notes. Some people might find comments to contain useful information or can even use them in the code generation phase to reflect changes between the input and output files. This subject is left for the developer to decide, but in this tutorial, comments are ignored. 

The second box holds all the lexical tokens considered unfamiliar to the language syntax. For example, many languages need to mark characters like `@` or `~` as error tokens since they are not part of the syntax. Again, this depends on the programming language being developed, one can define a functionality for those characters later in the semantic phase, however, this tutorial does not allow the usage of those characters. Luckily, one does not have to list all the possible characters that must land on error states, an edge labeled OTHER is capable of redirecting all unspecified characters to a particular state (more details in the documentation). The next step of this tutorial gives further details on how to customize error messages. 

The final box, called the reserved words box, keeps the lexical tokens temporarly, in fact, latters are placed in box for a short time while waiting for their values to be verified. Not all lexical tokens visit this box. For instance, a lexical token labled `semicolon` has a complete definition of what its value can be and therefore does not need to visit this box. However, some lexical tokens cover a large set of words of which several can be reserved and deserve to be promoted into their own labels. A common example are the reserved words `while`, `for`, `if`, etc... . By default, those words can be part of an `identifier` lexical token responsible for defining a variable name or/and type. Since those words can possibly have a meaninig in the programming language syntax, they must be configured to be scanned by the library and their lexical token altered to reflect the new label. The calculator lexical configuration file reserves the number zero, defined by the lexical state machine to be a `T_INTEGER`, and updates its label to a `T_ZERO`. Of course a better way to obtain the same result is by adjusting the state machine to have the digit zero land on a `T_ZERO` state, but the current method is followed to demonstrate the usage of the reserved box.

The last information defined in this configuration file is the new line representation. Different operating systems have different representations for a new line. Also some editors allow toggling between the options regardless of the operating system used. For that reason, this information is required in this file. *This attribute might be elimiated if a method has been implemented for automatically detecting the new line option used by the input file.*

Lexical configuration: <a href="resources/src/calculator/lexical_config.json">lexical_config.json</a>  
JSON description: <a href="src/lexical#configuration">Doc</a>

#### Step 3: Create a "lexical_errors.json" file
Now that error lexical tokens are recognized by the library, the compiler needs to display meaningful error messages for the user. Two methods are available for customizing error messages. The first method is mapping the lexical token name to an error message. The second method is defining a default error message displayed when no entry is found for the lexical token name. In this tutorial, both methods are used but the default error message is ignored since the single error lexical token is mapped to an error message.

Lexical error message: <a href="resources/src/calculator/lexical_errors.json">lexical_config.json</a>  
JSON description: <a href="src/lexical#error-messages">Doc</a>
